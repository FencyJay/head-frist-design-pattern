# 《Head First 设计模式》和实例
> **设计模式**是在某种情景下，针对某问题的某种解决方案

- **随时想到系统以后可能需要的变化以及应付变化的原则**
- **所有的原则都应该在有帮助的时候才遵守**
- **所有的设计都不免需要折中**
- 良好的OO设计必须具备可复用、可扩充、可维护三个特性
- 代码应该如同晚霞中的莲花一样地关闭（免于改变），如同晨曦中的莲花一样地开放（能够扩展）

## 1. 设计原则
1. 找出应用中**可能需要变化之处**，把它们**独立出来**，**不要和那些不需要变化的代码混在一起**
2. **面向接口编程**，而不是面向实现编程

> 接口是Java中的`interface`，当然这里强调的不是它，面向接口编程强调的是**多态**。
3. 多用组合，少用继承
4. 为**松耦合**的实现努力，减少系统组件之间的依赖
5. **开放-关闭原则**: 类应该对扩展开放，对修改关闭
6. **依赖倒置原则**: 依赖抽象，不要依赖具体实现类
> 依赖倒置原则变量不持有具体实现类的引用，可以改用工厂模式来代替。
> 这就类似在Spring中注入的bean是具体实现，但是它们的引用却是接口，这样声明的字段不用管注入的是谁，
> 直接调用方法即可，而且可以在运行时改变实现类型，"切换不同的策略"。
7. 最少知识原则：一个类对于其他类知道的越少越好，类只和它的密友谈话
8. 避免循环依赖
9. **单一职责(SRP)**: 尽可能让每个类保持单一的责任，当一个模块或一个类被设计成只支持一组相关的功能时，
我们称它为高内聚，反之，当被设计成支持一组不相关的功能时，
我们称它为低内聚（内聚用来衡量一个类或模块紧密地达到单一职责）
## 2. 策略模式
> **策略模式**：定义了一系列算法或策略，并将每个算法封装在独立的类中，使得它们可以互相替换。

我对策略模式的理解：
1. 解耦与职责分离
- 没有策略模式的设计中，通常会把多种行为写在同一个类里，用一堆 if-else 或者 switch 来决定执行哪段逻辑。这样代码臃肿、可读性差，也不利于维护。  
- 采用策略模式后，把每一种行为都做成一个独立的策略类，实现同一个接口。上下文（Context）只负责持有一个接口引用、并在适当的时候调用它。

```java
public abstract class Duck {
    // 上下文（Context）只负责持有一个接口引用、并在适当的时候调用它
    protected FlyBahavior flyBahavior;
    protected QuackBehavior quackBehavior;

    public Duck(){

    }

    /**
     * 鸭子飞行能力委托给行为接口
     */
    public void performFly(){
        flyBahavior.fly();
    }

    // 委托给行为接口
    public void performQuack() {
        quackBehavior.quack();
    }
// ...... 

}
```
2.  动态可替换与运行时灵活性
- 过向上下文注入不同的策略实例，或者在运行中调用 setStrategy()，就能立刻改变程序的行为，而不用改动或重编译现有类。
- 这对需求常变、或者在不同场景下要使用不同算法的系统来说，提供了极大的灵活性。例如，同一个支付模块里，可以在支付宝、微信、银行卡之间动态切换支付策略。
3. 符合开闭原则
- 单个策略类职责单一、代码量小，非常适合单元测试
- 同样的策略也可以在不同的上下文中复用，比如在一个图像处理项目里，对同一张图片做不同滤镜，只要把滤镜算法抽成策略，就能在多个处理流程里共享。


  策略模式代码示例在 chapter1 包下，先看下面的 uml 类图好理解，将鸭子的能力拆分并封装，
组合到Duck类中，实现高内聚低耦合，灵活扩展鸭子的能力。
另外在 Duck 类中有 setFlyBehavior() 和 setQuackBehavior 支持动态改变鸭子的行为。
![](images/chapter1.png)
## 3. 观察者模式

> **观察者模式**：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象， 
> 当主题对象的状态发生变化时，所有依赖于它的观察者都得到通知并被自动更新。

观察者模式又叫发布-订阅模式，或者是事件系统。

观察者模式的核心是**解耦**，它把观察者和被观察者之间的关系从紧耦合变成了松耦合。

JDK 内置了观察者模式的实现，java.util.Observable 和 java.util.Observer，不过从 Java 9 开始就被标记为过时了。
所以我们自己实现一个观察者模式的例子。源码 chapter2 ，以天气气象站为例，天气数据是主题，显示器是观察者。

![](images/chapter2.png)

为了遵循 **单一职责原则（SRP）** 和 **接口隔离原则（ISP）** ， 观察者模式中的职责分为两个接口  
- Observer 接口只负责接收主题（Subject）推送的状态更新（update(...)）。
- DisplayElement 接口只负责定义展示行为（display()）。
这个设计也体现出松耦合，当你仅仅实现DispalyElemnt时，你的具体类就是一个简单的气象展示对象，没有推送功能。

我对观察者模式的理解：
1. 解耦
- Subject（主题／被观察者）：定义注册、移除、通知观察者的接口。在示例中，由 WeatherData 实现。
- Observer（观察者）：定义 update(...) 方法，当主题状态改变时被调用。各显示器类（CurrentConditionsDisplay、StatisticsDisplay 等）都实现了它。
2. 扩展性
- 只要实现了 Observer 和 DisplayElement 接口，就可以随时新增新的显示板块（比如手机端显示、图表显示等），无需改动已有代码，符合“开闭原则”。
3. 优点
- 松耦合：主题只知道观察者接口，反之亦然，双方不直接依赖具体类；
- 灵活可扩展：可动态增删观察者、添加新观察者类型；
- 职责单一：主题负责管理数据和通知，观察者专注于如何响应和展示。